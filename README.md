# RBE

[![Stable](https://img.shields.io/badge/docs-stable-blue.svg)](https://shiyibai5315.github.io/RBE.jl/stable/)
[![Dev](https://img.shields.io/badge/docs-dev-blue.svg)](https://shiyibai5315.github.io/RBE.jl/dev/)
[![Build Status](https://github.com/shiyibai5315/RBE.jl/actions/workflows/CI.yml/badge.svg?branch=main)](https://github.com/shiyibai5315/RBE.jl/actions/workflows/CI.yml?query=branch%3Amain)
[![Coverage](https://codecov.io/gh/shiyibai5315/RBE.jl/branch/main/graph/badge.svg)](https://codecov.io/gh/shiyibai5315/RBE.jl)


## Introduction

In the MH algorithm, the proposal \(m^*\) is generated by first drawing \(x^*\) from the normal distribution \(\mathcal{N}(0, \alpha L^2 / (2\pi^2))\), then setting \(m^* = \text{round}(x^*)\), and accepting it with probability \(q(m^*|m)\) given by:

\[
q(m^*|m) = 
\begin{cases} 
\text{erf} \left( \frac{1}{2} \sqrt{\frac{\alpha L^2}{\pi^2}} \right), & m^* = 0 \\
\frac{1}{2} \left[ \text{erf} \left( \frac{|m^*| + 1/2}{\sqrt{\alpha L^2 / \pi^2}} \right) - \text{erf} \left( \frac{|m^*| - 1/2}{\sqrt{\alpha L^2 / \pi^2}} \right) \right], & m^* \neq 0
\end{cases}
\]

MH sampling code is as follows:

```julia
function acceptance_probability(m_star::Float64, α::Float64, L::Float64)
    if m_star == 0
        return erf(1 / (2 * sqrt(α * L^2 / π^2)))
    else
        sqrt_val = sqrt(α * L^2 / π^2)
        return 0.5 * (erf((abs(m_star) + 0.5) / sqrt_val) - erf((abs(m_star) - 0.5) / sqrt_val))
    end
end

function mh_sample(α::Float64, L::Float64)
    sample = 0.0
    while sample == 0.0
        x_star = rand(Normal(0, sqrt(α * L^2 / (2 * π^2))))
        m_star = Float64(round(Int, x_star))
        q = acceptance_probability(m_star, α, L)
        if rand() < q && m_star !=0
            sample =  m_star
            break
        end
    end
    return sample
end

function sampling(α, L, n)
    k_set = []
    for i in 0:2*L
        k_vector = generate_k_vector(α,L)
        push!(k_set, k_vector)
    end
    k_set = collect(k_set)
    z = sum(exp(-(norm(k)^2) / (4*α)) for k in k_set)
    prob = [exp(-(norm(k)^2) / (4*α)) / z for k in k_set]
    samples = sample(k_set, weights(prob), n)

    return samples
end
```


Here is the equation of long range coulomb force using RBE algorithm

\[
\mathbf{F}_{i,1} \approx \mathbf{F}^*_{i,1} := -\sum_{\ell=1}^{p} \frac{4\pi q_i}{V k^2_\ell} \mathbf{k}_\ell \Im \bigl( e^{-i\mathbf{k}_\ell \cdot \mathbf{r}_i} \rho (\mathbf{k}_\ell) \bigr)
\tag{3.6}
\]

The code for calculating the long range coulomb force is as follows:
```julia
function calculate_Fi(i::Int, p::Int, L::Float64, α::Float64, charges::Vector{Float64}, positions::Matrix{Tuple{Float64, Float64, Float64}}, rho_k::Vector{Complex{Float64}}, samples::Vector)
    V = L^3
    Fi = zeros(Float64, 3)
    qi = charges[i]
    ri = [positions[i]...]

    for j in 1:p
        k2_ell = norm(samples[j])^2
        exp_term = exp(-1im * dot(samples[j], ri))
        imag_part = imag(exp_term * rho_k[j])
        Fi += - (4 * π * samples[j] * qi) / (V * k2_ell) * imag_part
    end

    return Fi
end
```
Here uses the same batch of frequencies \(p\). This reduces the complexity per iteration for the frequency part to \( \mathcal{O}(pN) \). This implies that the RBE method has linear complexity per time step if one chooses \( p = \mathcal{O}(1) \).

